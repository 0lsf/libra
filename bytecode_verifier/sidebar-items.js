initSidebarItems({"mod":[["absint",""],["acquires_list_verifier","This module implements a checker for verifying properties about the acquires list on function definitions. Function definitions must annotate the global resources (declared in that module) accesssed by `BorrowGlobal`, `MoveFrom`, and any transitive function calls The list of acquired resources (stored in `FunctionDefinition`'s `acquires_global_resources` field) must have: - No duplicate resources (checked by `check_duplication`) - No missing resources (any resource acquired must be present) - No additional resources (no extraneous resources not actually acquired)"],["check_duplication","This module implements a checker for verifying that each vector in a CompiledModule contains distinct values. Successful verification implies that an index in vector can be used to uniquely name the entry at that index. Additionally, the checker also verifies the following: - struct and field definitions are consistent - the handles in struct and function definitions point to the self module index - all struct and function handles pointing to the self module index have a definition"],["code_unit_verifier","This module implements the checker for verifying correctness of function bodies. The overall verification is split between stack_usage_verifier.rs and abstract_interpreter.rs. CodeUnitVerifier simply orchestrates calls into these two files."],["constants","This module implements a checker for verifying that - a constant's type only refers to primitive types - a constant's data serializes correctly for that type"],["control_flow","This module implements a checker for verifies control flow. The following properties are ensured: - All forward jumps do not enter into the middle of a loop - All \"breaks\" (forward, loop-exiting jumps) go to the \"end\" of the loop - All \"continues\" (back jumps in a loop) are only to the current loop"],["control_flow_graph","This module defines the control-flow graph uses for bytecode verification."],["instantiation_loops","This implements an algorithm that detects loops during the instantiation of generics."],["locals_safety","This module defines the transfer functions for verifying local safety of a procedure body. It is concerned with the assignment state of a local variable at the time of usage, which is a control flow sensitive check"],["reference_safety","This module defines the transfer functions for verifying reference safety of a procedure body. The checks include (but are not limited to) - verifying that there are no dangaling references, - accesses to mutable references are safe - accesses to global storage references are safe"],["resolver","This module implements a resolver for importing a SignatureToken defined in one module into another. This functionaliy is used in verify_module_dependencies and verify_script_dependencies."],["resources","This module implements a checker for verifying that a non-resource struct does not have resource fields inside it."],["signature","This module implements a checker for verifying signature tokens used in types of function parameters, locals, and fields of structs are well-formed. References can only occur at the top-level in all tokens.  Additionally, references cannot occur at all in field types."],["stack_usage_verifier","This module implements a checker for verifying that basic blocks in the bytecode instruction sequence of a function use the evaluation stack in a balanced manner. Every basic block, except those that end in Ret (return to caller) opcode, must leave the stack height the same as at the beginning of the block. A basic block that ends in Ret opcode must increase the stack height by the number of values returned by the function as indicated in its signature. Additionally, the stack height must not dip below that at the beginning of the block for any basic block."],["struct_defs","This module provides a checker for verifing that struct definitions in a module are not recursive. Since the module dependency graph is acylic by construction, applying this checker to each module in isolation guarantees that there is no structural recursion globally."],["type_safety","This module defines the transfer functions for verifying type safety of a procedure body. It does not utilize control flow, but does check each block independently"],["unused_entries",""],["verifier","This module contains the public APIs supported by the bytecode verifier."]]});