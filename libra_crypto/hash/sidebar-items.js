initSidebarItems({"static":[["ACCUMULATOR_PLACEHOLDER_HASH","Placeholder hash of `Accumulator`."],["GENESIS_BLOCK_ID","Genesis block id is used as a parent of the very first block executed by the executor."],["PRE_GENESIS_BLOCK_ID","Block id reserved as the id of parent block of the genesis block."],["SPARSE_MERKLE_PLACEHOLDER_HASH","Placeholder hash of `SparseMerkleTree`."]],"struct":[["DefaultHasher","Our preferred hashing schema, outputting [`HashValue`]s. * Hashing is parameterized by a `domain` to prevent domain ambiguity attacks. * The existence of serialization/deserialization function rules out any formatting ambiguity. * Assuming that the `domain` seed is used only once per Rust type, or that the serialization carries enough type information to avoid ambiguities within a same domain. * Only used internally within this crate"],["DiscoveryMsgHasher","The hasher used to compute the hash of a DiscoveryMsg object."],["EventAccumulatorHasher","The hasher used to compute the hash of an internal node in the event accumulator."],["HashValue","Output value of our hash function. Intentionally opaque for safety and modularity."],["HashValueBitIterator","An iterator over `HashValue` that generates one bit for each iteration."],["SparseMerkleInternalHasher","The hasher used to compute the hash of an internal node in the Sparse Merkle Tree."],["TestOnlyHasher","The hasher used only for testing. It doesn't have a salt."],["TransactionAccumulatorHasher","The hasher used to compute the hash of an internal node in the transaction accumulator."]],"trait":[["CryptoHash","A type that implements `CryptoHash` can be hashed by a cryptographic hash function and produce a `HashValue`. Each type needs to have its own `Hasher` type."],["CryptoHasher","A trait for generating hash from arbitrary stream of bytes."],["TestOnlyHash","Provides a test_only_hash() method that can be used in tests on types that implement `serde::Serialize`."]]});